/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/images/combinedImage.png":
/*!**************************************!*\
  !*** ./src/images/combinedImage.png ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + \"39c52251638f49e350eb53ed6a4abac9.png\");\n\n//# sourceURL=webpack://cellular-redstone/./src/images/combinedImage.png?");

/***/ }),

/***/ "./src/blocks/air.ts":
/*!***************************!*\
  !*** ./src/blocks/air.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Air = void 0;\nconst block_1 = __webpack_require__(/*! ../core/block */ \"./src/core/block.ts\");\nconst direction_1 = __webpack_require__(/*! ../core/direction */ \"./src/core/direction.ts\");\nconst block_fetching_1 = __webpack_require__(/*! ../utils/block_fetching */ \"./src/utils/block_fetching.ts\");\nconst create_block_1 = __webpack_require__(/*! ../utils/create_block */ \"./src/utils/create_block.ts\");\nconst piston_head_1 = __webpack_require__(/*! ./piston_head */ \"./src/blocks/piston_head.ts\");\nclass Air {\n    type = block_1.BlockType.Air;\n    constructor({} = {}) { }\n    update(position, blocks) {\n        for (const direction of (0, direction_1.getAllDirections)()) {\n            const neighbour = (0, block_fetching_1.getNeighbourBlock)(position, blocks, direction);\n            const oppositeDirection = (0, direction_1.getOppositeDirection)(direction);\n            if ((0, block_1.isBlock)(neighbour, block_1.BlockType.Piston) &&\n                neighbour.direction === oppositeDirection &&\n                neighbour.isBeingPowered) {\n                return new piston_head_1.PistonHead({ direction: neighbour.direction });\n            }\n            else if (\n            // TODO: check if instance of movable block\n            // TODO: add movement direction\n            (0, block_1.isMoveableBlock)(neighbour) &&\n                neighbour.movementDirection === oppositeDirection &&\n                neighbour.movement === block_1.Movement.Pending) {\n                return (0, create_block_1.createBlock)(neighbour.type, {\n                    ...neighbour,\n                    movement: block_1.Movement.Complete,\n                    movementDirection: oppositeDirection\n                });\n            }\n        }\n        return new Air();\n    }\n    subupdate(position, blocks) {\n        return new Air(this);\n    }\n    toString() {\n        return '[ ]';\n    }\n    getTextureName() {\n        return '';\n    }\n    isOutputtingPower() {\n        return false;\n    }\n    getMovementMethod() {\n        return block_1.BlockMovement.Breaks;\n    }\n}\nexports.Air = Air;\n(0, create_block_1.addCreateBlockFunction)(block_1.BlockType.Air, Air);\n\n\n//# sourceURL=webpack://cellular-redstone/./src/blocks/air.ts?");

/***/ }),

/***/ "./src/blocks/glass_block.ts":
/*!***********************************!*\
  !*** ./src/blocks/glass_block.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GlassBlock = void 0;\nconst block_1 = __webpack_require__(/*! ../core/block */ \"./src/core/block.ts\");\nconst direction_1 = __webpack_require__(/*! ../core/direction */ \"./src/core/direction.ts\");\nconst moveable_block_1 = __webpack_require__(/*! ../core/moveable_block */ \"./src/core/moveable_block.ts\");\nconst create_block_1 = __webpack_require__(/*! ../utils/create_block */ \"./src/utils/create_block.ts\");\nclass GlassBlock {\n    type = block_1.BlockType.GlassBlock;\n    movement;\n    movementDirection;\n    constructor({ movement = block_1.Movement.None, movementDirection = direction_1.Direction.Up } = {}) {\n        this.movement = movement;\n        this.movementDirection = movementDirection;\n    }\n    update(position, blocks) {\n        const movementUpdateChange = (0, moveable_block_1.updateMovement)(position, blocks, this.movement, this.movementDirection);\n        if (movementUpdateChange.type === moveable_block_1.MovementUpdateType.BlockChange) {\n            return movementUpdateChange.block;\n        }\n        else {\n            return new GlassBlock(movementUpdateChange.state);\n        }\n    }\n    subupdate(position, blocks) {\n        return new GlassBlock(this);\n    }\n    toString() {\n        return `MB${{\n            [block_1.Movement.None]: '',\n            [block_1.Movement.Pending]: '?',\n            [block_1.Movement.Complete]: '*',\n            [block_1.Movement.RetractionPending]: '<',\n            [block_1.Movement.RetractionComplete]: '^'\n        }[this.movement]}`;\n    }\n    getTextureName() {\n        return `glass` + (0, moveable_block_1.getMovementTextureName)(this);\n    }\n    isOutputtingPower() {\n        return false;\n    }\n    getMovementMethod() {\n        return this.movement === block_1.Movement.None\n            ? block_1.BlockMovement.Moveable\n            : block_1.BlockMovement.Immovable;\n    }\n}\nexports.GlassBlock = GlassBlock;\n(0, create_block_1.addCreateBlockFunction)(block_1.BlockType.GlassBlock, GlassBlock);\n\n\n//# sourceURL=webpack://cellular-redstone/./src/blocks/glass_block.ts?");

/***/ }),

/***/ "./src/blocks/piston.ts":
/*!******************************!*\
  !*** ./src/blocks/piston.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Piston = void 0;\nconst block_1 = __webpack_require__(/*! ../core/block */ \"./src/core/block.ts\");\nconst direction_1 = __webpack_require__(/*! ../core/direction */ \"./src/core/direction.ts\");\nconst moveable_block_1 = __webpack_require__(/*! ../core/moveable_block */ \"./src/core/moveable_block.ts\");\nconst block_fetching_1 = __webpack_require__(/*! ../utils/block_fetching */ \"./src/utils/block_fetching.ts\");\nconst create_block_1 = __webpack_require__(/*! ../utils/create_block */ \"./src/utils/create_block.ts\");\nconst general_1 = __webpack_require__(/*! ../utils/general */ \"./src/utils/general.ts\");\nclass Piston {\n    type = block_1.BlockType.Piston;\n    isBeingPowered;\n    direction;\n    movement;\n    movementDirection;\n    constructor({ isBeingPowered = false, direction = direction_1.Direction.Up, movement = block_1.Movement.None, movementDirection = direction_1.Direction.Up } = {}) {\n        this.isBeingPowered = isBeingPowered;\n        this.direction = direction;\n        this.movement = movement;\n        this.movementDirection = movementDirection;\n    }\n    update(position, blocks) {\n        let movementUpdateChange;\n        if (this.isBeingPowered) {\n            movementUpdateChange = {\n                type: moveable_block_1.MovementUpdateType.StateChange,\n                state: {\n                    movement: this.movement,\n                    movementDirection: this.movementDirection\n                }\n            };\n        }\n        else {\n            movementUpdateChange = (0, moveable_block_1.updateMovement)(position, blocks, this.movement, this.movementDirection);\n        }\n        if (movementUpdateChange.type === moveable_block_1.MovementUpdateType.BlockChange) {\n            return movementUpdateChange.block;\n        }\n        else {\n            const nonFrontDirections = (0, direction_1.getOtherDirections)(direction_1.Direction.Up);\n            const nonFrontBlocks = (0, block_fetching_1.getNeighbourBlocks)(position, blocks, nonFrontDirections);\n            const isBeingPowered = (0, general_1.zipArrays)(nonFrontDirections, nonFrontBlocks).some(([neighbourDirection, block]) => block.isOutputtingPower((0, direction_1.getOppositeDirection)((0, direction_1.getRelativeDirection)(neighbourDirection, this.direction))));\n            return new Piston({\n                ...movementUpdateChange.state,\n                isBeingPowered,\n                direction: this.direction\n            });\n        }\n    }\n    subupdate(position, blocks) {\n        return new Piston(this);\n    }\n    toString() {\n        return `P${this.isBeingPowered ? '*' : ''}`;\n    }\n    getTextureName(position, blocks) {\n        const frontBlock = (0, block_fetching_1.getNeighbourBlock)(position, blocks, direction_1.Direction.Up);\n        const isExtended = (0, block_1.isBlock)(frontBlock, block_1.BlockType.PistonHead) &&\n            frontBlock.direction === this.direction;\n        const isPowered = this.isBeingPowered ||\n            (this.movement === block_1.Movement.None &&\n                (0, block_1.isMoveableBlock)(frontBlock) &&\n                frontBlock.movement === block_1.Movement.Pending &&\n                frontBlock.movementDirection === this.direction);\n        const tex = `piston${isExtended ? '_extended' : isPowered ? '_on' : '_off'}_${this.direction.toLowerCase()}` +\n            (isPowered || isExtended ? '' : (0, moveable_block_1.getMovementTextureName)(this));\n        return tex;\n    }\n    isOutputtingPower() {\n        return false;\n    }\n    getMovementMethod() {\n        return this.isBeingPowered\n            ? block_1.BlockMovement.Immovable\n            : block_1.BlockMovement.Moveable;\n    }\n}\nexports.Piston = Piston;\n(0, create_block_1.addCreateBlockFunction)(block_1.BlockType.Piston, Piston);\n\n\n//# sourceURL=webpack://cellular-redstone/./src/blocks/piston.ts?");

/***/ }),

/***/ "./src/blocks/piston_head.ts":
/*!***********************************!*\
  !*** ./src/blocks/piston_head.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PistonHead = void 0;\nconst block_1 = __webpack_require__(/*! ../core/block */ \"./src/core/block.ts\");\nconst direction_1 = __webpack_require__(/*! ../core/direction */ \"./src/core/direction.ts\");\nconst block_fetching_1 = __webpack_require__(/*! ../utils/block_fetching */ \"./src/utils/block_fetching.ts\");\nconst create_block_1 = __webpack_require__(/*! ../utils/create_block */ \"./src/utils/create_block.ts\");\nconst air_1 = __webpack_require__(/*! ./air */ \"./src/blocks/air.ts\");\nclass PistonHead {\n    type = block_1.BlockType.PistonHead;\n    isRetracting;\n    direction;\n    constructor({ isRetracting = false, direction = direction_1.Direction.Up } = {}) {\n        this.isRetracting = isRetracting;\n        this.direction = direction;\n    }\n    update(position, blocks) {\n        const backBlock = (0, block_fetching_1.getNeighbourBlock)(position, blocks, direction_1.Direction.Down);\n        const frontBlock = (0, block_fetching_1.getNeighbourBlock)(position, blocks, direction_1.Direction.Up);\n        if ((0, block_1.isBlock)(backBlock, block_1.BlockType.Piston)) {\n            if (this.isRetracting &&\n                (0, block_1.isMoveableBlock)(frontBlock) &&\n                frontBlock.movement === block_1.Movement.RetractionPending &&\n                frontBlock.movementDirection === this.direction) {\n                return (0, create_block_1.createBlock)(frontBlock.type, {\n                    ...frontBlock,\n                    movement: block_1.Movement.RetractionComplete,\n                    movementDirection: this.direction\n                });\n            }\n            else if (this.isRetracting &&\n                (0, block_1.isMoveableBlock)(frontBlock) &&\n                frontBlock.movement === block_1.Movement.Pending &&\n                frontBlock.movementDirection === (0, direction_1.getOppositeDirection)(this.direction)) {\n                // TODO: once subticks are added all motions should be cancelled\n                // at end of each tick\n                // this is a TEMPORARY measure\n                return new air_1.Air();\n            }\n            else if (this.isRetracting &&\n                (0, block_1.isMoveableBlock)(frontBlock) &&\n                frontBlock.getMovementMethod() === block_1.BlockMovement.Immovable) {\n                return new air_1.Air();\n            }\n            else if (this.isRetracting && !(0, block_1.isMoveableBlock)(frontBlock)) {\n                return new air_1.Air();\n            }\n            else {\n                return new PistonHead({\n                    isRetracting: !backBlock.isBeingPowered,\n                    direction: this.direction\n                });\n            }\n        }\n        else {\n            return new air_1.Air();\n        }\n    }\n    subupdate(position, blocks) {\n        return new PistonHead(this);\n    }\n    toString() {\n        return `PH${this.isRetracting ? '<' : ''}`;\n    }\n    getTextureName() {\n        return `piston_head${this.isRetracting ? '_retracting' : ''}_${this.direction.toLowerCase()}`;\n    }\n    isOutputtingPower() {\n        return false;\n    }\n    getMovementMethod() {\n        return block_1.BlockMovement.Immovable;\n    }\n}\nexports.PistonHead = PistonHead;\n(0, create_block_1.addCreateBlockFunction)(block_1.BlockType.PistonHead, PistonHead);\n\n\n//# sourceURL=webpack://cellular-redstone/./src/blocks/piston_head.ts?");

/***/ }),

/***/ "./src/blocks/redstone_block.ts":
/*!**************************************!*\
  !*** ./src/blocks/redstone_block.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RedstoneBlock = void 0;\nconst block_1 = __webpack_require__(/*! ../core/block */ \"./src/core/block.ts\");\nconst direction_1 = __webpack_require__(/*! ../core/direction */ \"./src/core/direction.ts\");\nconst moveable_block_1 = __webpack_require__(/*! ../core/moveable_block */ \"./src/core/moveable_block.ts\");\nconst create_block_1 = __webpack_require__(/*! ../utils/create_block */ \"./src/utils/create_block.ts\");\nclass RedstoneBlock {\n    type = block_1.BlockType.RedstoneBlock;\n    movement;\n    movementDirection;\n    constructor({ movement = block_1.Movement.None, movementDirection = direction_1.Direction.Up } = {}) {\n        this.movement = movement;\n        this.movementDirection = movementDirection;\n    }\n    update(position, blocks) {\n        const movementUpdateChange = (0, moveable_block_1.updateMovement)(position, blocks, this.movement, this.movementDirection);\n        if (movementUpdateChange.type === moveable_block_1.MovementUpdateType.BlockChange) {\n            return movementUpdateChange.block;\n        }\n        else {\n            return new RedstoneBlock(movementUpdateChange.state);\n        }\n    }\n    subupdate(position, blocks) {\n        return new RedstoneBlock(this);\n    }\n    toString() {\n        return 'RDB';\n    }\n    getTextureName() {\n        return `redstone_block` + (0, moveable_block_1.getMovementTextureName)(this);\n    }\n    isOutputtingPower() {\n        return true;\n    }\n    getMovementMethod() {\n        return block_1.BlockMovement.Moveable;\n    }\n}\nexports.RedstoneBlock = RedstoneBlock;\n(0, create_block_1.addCreateBlockFunction)(block_1.BlockType.RedstoneBlock, RedstoneBlock);\n\n\n//# sourceURL=webpack://cellular-redstone/./src/blocks/redstone_block.ts?");

/***/ }),

/***/ "./src/blocks/redstone_lamp.ts":
/*!*************************************!*\
  !*** ./src/blocks/redstone_lamp.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RedstoneLamp = void 0;\nconst block_1 = __webpack_require__(/*! ../core/block */ \"./src/core/block.ts\");\nconst direction_1 = __webpack_require__(/*! ../core/direction */ \"./src/core/direction.ts\");\nconst moveable_block_1 = __webpack_require__(/*! ../core/moveable_block */ \"./src/core/moveable_block.ts\");\nconst block_fetching_1 = __webpack_require__(/*! ../utils/block_fetching */ \"./src/utils/block_fetching.ts\");\nconst create_block_1 = __webpack_require__(/*! ../utils/create_block */ \"./src/utils/create_block.ts\");\nclass RedstoneLamp {\n    type = block_1.BlockType.RedstoneLamp;\n    isBeingPowered;\n    movement;\n    movementDirection;\n    constructor({ isBeingPowered = false, movement = block_1.Movement.None, movementDirection = direction_1.Direction.Up } = {}) {\n        this.isBeingPowered = isBeingPowered;\n        this.movement = movement;\n        this.movementDirection = movementDirection;\n    }\n    update(position, blocks) {\n        const movementUpdateChange = (0, moveable_block_1.updateMovement)(position, blocks, this.movement, this.movementDirection);\n        if (movementUpdateChange.type === moveable_block_1.MovementUpdateType.BlockChange) {\n            return movementUpdateChange.block;\n        }\n        else {\n            for (const direction of (0, direction_1.getAllDirections)()) {\n                const neighbour = (0, block_fetching_1.getNeighbourBlock)(position, blocks, direction);\n                const isBeingPowered = neighbour.isOutputtingPower((0, direction_1.getOppositeDirection)(direction));\n                if (isBeingPowered) {\n                    return new RedstoneLamp({\n                        ...movementUpdateChange.state,\n                        isBeingPowered: true\n                    });\n                }\n            }\n            return new RedstoneLamp({\n                ...movementUpdateChange.state,\n                isBeingPowered: false\n            });\n        }\n    }\n    subupdate(position, blocks) {\n        return new RedstoneLamp(this);\n    }\n    toString() {\n        return 'RDB';\n    }\n    getTextureName() {\n        return (`redstone_lamp_${this.isBeingPowered ? 'on' : 'off'}` +\n            (0, moveable_block_1.getMovementTextureName)(this));\n    }\n    isOutputtingPower() {\n        return false;\n    }\n    getMovementMethod() {\n        return block_1.BlockMovement.Moveable;\n    }\n}\nexports.RedstoneLamp = RedstoneLamp;\n(0, create_block_1.addCreateBlockFunction)(block_1.BlockType.RedstoneLamp, RedstoneLamp);\n\n\n//# sourceURL=webpack://cellular-redstone/./src/blocks/redstone_lamp.ts?");

/***/ }),

/***/ "./src/blocks/redstone_torch.ts":
/*!**************************************!*\
  !*** ./src/blocks/redstone_torch.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RedstoneTorch = void 0;\nconst block_1 = __webpack_require__(/*! ../core/block */ \"./src/core/block.ts\");\nconst direction_1 = __webpack_require__(/*! ../core/direction */ \"./src/core/direction.ts\");\nconst block_fetching_1 = __webpack_require__(/*! ../utils/block_fetching */ \"./src/utils/block_fetching.ts\");\nconst create_block_1 = __webpack_require__(/*! ../utils/create_block */ \"./src/utils/create_block.ts\");\nclass RedstoneTorch {\n    type = block_1.BlockType.RedstoneTorch;\n    isBeingPowered;\n    direction;\n    constructor({ isBeingPowered = false, direction = direction_1.Direction.Up } = {}) {\n        // const { isBeingPowered = false, direction = Direction.Up } = state\n        this.isBeingPowered = isBeingPowered;\n        this.direction = direction;\n    }\n    subupdate(position, blocks) {\n        const backBlock = (0, block_fetching_1.getNeighbourBlock)(position, blocks, direction_1.Direction.Down);\n        const isBeingPowered = backBlock.isOutputtingPower(this.direction);\n        return new RedstoneTorch({ isBeingPowered, direction: this.direction });\n    }\n    update(position, blocks) {\n        return new RedstoneTorch(this);\n    }\n    toString() {\n        return `RT${this.isOn() ? '*' : ''}`;\n    }\n    getTextureName() {\n        return `redstone_torch_${this.isOn() ? 'on' : 'off'}_${this.direction.toLowerCase()}`;\n    }\n    isOutputtingPower(direction) {\n        return direction !== (0, direction_1.getOppositeDirection)(this.direction) && this.isOn();\n    }\n    getMovementMethod() {\n        return block_1.BlockMovement.Immovable;\n    }\n    isOn() {\n        return !this.isBeingPowered;\n    }\n}\nexports.RedstoneTorch = RedstoneTorch;\n(0, create_block_1.addCreateBlockFunction)(block_1.BlockType.RedstoneTorch, RedstoneTorch);\n\n\n//# sourceURL=webpack://cellular-redstone/./src/blocks/redstone_torch.ts?");

/***/ }),

/***/ "./src/containers/array2d.ts":
/*!***********************************!*\
  !*** ./src/containers/array2d.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Array2D = exports.Dict2D = exports.ChunkContainer = void 0;\nconst general_1 = __webpack_require__(/*! ../utils/general */ \"./src/utils/general.ts\");\nclass ChunkContainer {\n    chunks;\n    chunkSize;\n    createDefaultItem;\n    isDefaultItem;\n    listenToChunkCreation;\n    constructor(chunkSize, createDefaultItem, isDefaultItem, listenToChunkCreation = false) {\n        this.chunks = {};\n        this.chunkSize = chunkSize;\n        this.createDefaultItem = createDefaultItem;\n        this.isDefaultItem = isDefaultItem;\n        this.listenToChunkCreation = listenToChunkCreation;\n    }\n    clone(other) {\n        // chunk size must be same\n        this.chunks = other.chunks;\n    }\n    getChunkIndex(v) {\n        return `${Math.floor(v.x / this.chunkSize)} ${Math.floor(v.y / this.chunkSize)}`;\n    }\n    getBlockPositionInChunk(v) {\n        let x = v.x % this.chunkSize;\n        if (x < 0) {\n            x += this.chunkSize;\n        }\n        let y = v.y % this.chunkSize;\n        if (y < 0) {\n            y += this.chunkSize;\n        }\n        return { x, y };\n    }\n    getBlockIndex(v) {\n        const { x, y } = this.getBlockPositionInChunk(v);\n        return x + y * this.chunkSize;\n    }\n    chunkIndexToVec2(chunkIndex) {\n        const [x, y] = chunkIndex.split(' ');\n        return { x: Number(x), y: Number(y) };\n    }\n    createChunk() {\n        const chunk = [];\n        const area = this.chunkSize * this.chunkSize;\n        for (let i = 0; i < area; ++i) {\n            chunk.push(this.createDefaultItem());\n        }\n        return chunk;\n    }\n    createChunkAtPosition(v) {\n        const chunkIndex = this.getChunkIndex(v);\n        const chunk = this.chunks[chunkIndex];\n        if (!chunk) {\n            if (this.listenToChunkCreation) {\n                console.log('creating chunk', chunkIndex);\n            }\n            this.chunks[chunkIndex] = this.createChunk();\n        }\n    }\n    createNeighbouringChunksAtPosition(v) {\n        const rv = this.getBlockPositionInChunk(v);\n        if (rv.x === 0) {\n            this.createChunkAtPosition({ x: v.x - this.chunkSize, y: v.y });\n        }\n        else if (rv.x === this.chunkSize - 1) {\n            this.createChunkAtPosition({ x: v.x + this.chunkSize, y: v.y });\n        }\n        if (rv.y === 0) {\n            this.createChunkAtPosition({ x: v.x, y: v.y - this.chunkSize });\n        }\n        else if (rv.y === this.chunkSize - 1) {\n            this.createChunkAtPosition({ x: v.x, y: v.y + this.chunkSize });\n        }\n    }\n    setValue(v, value) {\n        // build chunks at and around the position we attempt to set a block\n        this.createChunkAtPosition(v);\n        if (!this.isDefaultItem(value)) {\n            this.createNeighbouringChunksAtPosition(v);\n        }\n        const chunkIndex = this.getChunkIndex(v);\n        const blockIndex = this.getBlockIndex(v);\n        const chunk = this.chunks[chunkIndex];\n        chunk[blockIndex] = value;\n    }\n    getValue(v) {\n        const chunkIndex = this.getChunkIndex(v);\n        const blockIndex = this.getBlockIndex(v);\n        const chunk = this.chunks[chunkIndex];\n        // do not build a chunk if we attempt to query one which does not exist\n        if (!chunk) {\n            return this.createDefaultItem();\n        }\n        return chunk[blockIndex];\n    }\n    map(callback) {\n        const newContainer = new ChunkContainer(this.chunkSize, this.createDefaultItem, this.isDefaultItem);\n        for (const [index, chunk] of Object.entries(this.chunks)) {\n            const chunkPos = this.chunkIndexToVec2(index);\n            const chunkBlockPos = {\n                x: chunkPos.x * this.chunkSize,\n                y: chunkPos.y * this.chunkSize\n            };\n            for (let y = chunkBlockPos.y; y < chunkBlockPos.y + this.chunkSize; ++y) {\n                for (let x = chunkBlockPos.x; x < chunkBlockPos.x + this.chunkSize; ++x) {\n                    const position = { x, y };\n                    const value = this.getValue(position);\n                    const newValue = callback(value, position);\n                    newContainer.setValue(position, newValue);\n                }\n            }\n        }\n        const newChunksPositions = (0, general_1.getMissingKeys)(this.chunks, newContainer.chunks);\n        if (newChunksPositions.length > 0) {\n            console.log('Creating chunk(s)', newChunksPositions);\n        }\n        return newContainer;\n    }\n    mapToDict2D(callback) {\n        const dict2D = new Dict2D();\n        for (const [index, chunk] of Object.entries(this.chunks)) {\n            const chunkPos = this.chunkIndexToVec2(index);\n            const chunkBlockPos = {\n                x: chunkPos.x * this.chunkSize,\n                y: chunkPos.y * this.chunkSize\n            };\n            for (let y = chunkBlockPos.y; y < chunkBlockPos.y + this.chunkSize; ++y) {\n                for (let x = chunkBlockPos.x; x < chunkBlockPos.x + this.chunkSize; ++x) {\n                    const position = { x, y };\n                    const value = this.getValue(position);\n                    if (!this.isDefaultItem(value)) {\n                        const newValue = callback(value, position);\n                        dict2D.setValue(position, newValue);\n                    }\n                }\n            }\n        }\n        return dict2D;\n    }\n}\nexports.ChunkContainer = ChunkContainer;\nclass Dict2D {\n    items;\n    constructor(items) {\n        this.items = items ?? {};\n    }\n    clone(other) {\n        this.items = other.items;\n    }\n    getIndex(v) {\n        return `${v.x} ${v.y}`;\n    }\n    indexToVec2(i) {\n        const [x, y] = i.split(' ');\n        return { x: Number(x), y: Number(y) };\n    }\n    setValue(v, value) {\n        const index = this.getIndex(v);\n        this.items[index] = value;\n    }\n    getValue(v) {\n        const index = this.getIndex(v);\n        return this.items[index];\n    }\n    map(callback) {\n        const newContainer = new Dict2D();\n        for (const [index, value] of Object.entries(this.items)) {\n            const v = this.indexToVec2(index);\n            const newValue = callback(value, v);\n            newContainer.setValue(v, newValue);\n        }\n        return newContainer;\n    }\n    foreach(callback) {\n        for (const [index, value] of Object.entries(this.items)) {\n            const v = this.indexToVec2(index);\n            callback(value, v);\n        }\n    }\n}\nexports.Dict2D = Dict2D;\nclass Array2D {\n    width;\n    height;\n    array;\n    constructor(width, height, values) {\n        this.width = width;\n        this.height = height;\n        this.array = values;\n    }\n    static createWithDefaultValue(width, height, defaultValue) {\n        const values = new Array(width * height).fill(defaultValue);\n        return new Array2D(width, height, values);\n    }\n    length() {\n        return this.width * this.height;\n    }\n    getIndex(v) {\n        if (v.x >= 0 && v.y >= 0 && v.x < this.width && v.y < this.height) {\n            return v.y * this.width + v.x;\n        }\n        return -1;\n    }\n    setValue(v, value) {\n        const index = this.getIndex(v);\n        this.array[index] = value;\n    }\n    getValue(v) {\n        const index = this.getIndex(v);\n        return this.array[index];\n    }\n    toDictionary(filterFnc) {\n        const dict = {};\n        for (let y = 0; y < this.height; y++) {\n            for (let x = 0; x < this.width; x++) {\n                const key = `${x} ${y}`;\n                const value = this.getValue({ x, y });\n                if (filterFnc(value)) {\n                    dict[key] = value;\n                }\n            }\n        }\n        return dict;\n    }\n    toFormattedString(formatValue) {\n        let output = '';\n        for (let y = 0; y < this.height; y++) {\n            for (let x = 0; x < this.width; x++) {\n                const item = formatValue(this.getValue({ x, y }));\n                output += item + ' ';\n            }\n            output += '\\n';\n        }\n        return output;\n    }\n    map(callback) {\n        const newArray = [];\n        for (let y = 0; y < this.height; y++) {\n            for (let x = 0; x < this.width; x++) {\n                const value = this.getValue({ x, y });\n                const newValue = callback(value, { x, y });\n                newArray.push(newValue);\n            }\n        }\n        return new Array2D(this.width, this.height, newArray);\n    }\n}\nexports.Array2D = Array2D;\n\n\n//# sourceURL=webpack://cellular-redstone/./src/containers/array2d.ts?");

/***/ }),

/***/ "./src/containers/vec2.ts":
/*!********************************!*\
  !*** ./src/containers/vec2.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.vec2Apply = exports.vec2Zero = exports.vec2Multiply = exports.vec2Divide = exports.vec2Add = exports.vec2Subtract = exports.scalarToVec2 = exports.vec2 = void 0;\nfunction vec2(x, y) {\n    return { x, y };\n}\nexports.vec2 = vec2;\nfunction scalarToVec2(z) {\n    return { x: z, y: z };\n}\nexports.scalarToVec2 = scalarToVec2;\nconst vec2Subtract = (v, u) => {\n    return { x: v.x - u.x, y: v.y - u.y };\n};\nexports.vec2Subtract = vec2Subtract;\nconst vec2Add = (v, u) => {\n    return { x: v.x + u.x, y: v.y + u.y };\n};\nexports.vec2Add = vec2Add;\nconst vec2Divide = (v, u) => {\n    return { x: v.x / u.x, y: v.y / u.y };\n};\nexports.vec2Divide = vec2Divide;\nconst vec2Multiply = (v, u) => {\n    return { x: v.x * u.x, y: v.y * u.y };\n};\nexports.vec2Multiply = vec2Multiply;\nconst vec2Zero = () => {\n    return { x: 0, y: 0 };\n};\nexports.vec2Zero = vec2Zero;\nconst vec2Apply = (v, fnc) => {\n    return { x: fnc(v.x), y: fnc(v.y) };\n};\nexports.vec2Apply = vec2Apply;\n\n\n//# sourceURL=webpack://cellular-redstone/./src/containers/vec2.ts?");

/***/ }),

/***/ "./src/core/block.ts":
/*!***************************!*\
  !*** ./src/core/block.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isDirectionalBlock = exports.isMoveableBlock = exports.Movement = exports.isBlock = exports.BlockType = exports.BlockMovement = void 0;\nvar BlockMovement;\n(function (BlockMovement) {\n    BlockMovement[BlockMovement[\"Immovable\"] = 0] = \"Immovable\";\n    BlockMovement[BlockMovement[\"Moveable\"] = 1] = \"Moveable\";\n    BlockMovement[BlockMovement[\"Breaks\"] = 2] = \"Breaks\";\n})(BlockMovement || (exports.BlockMovement = BlockMovement = {}));\nvar BlockType;\n(function (BlockType) {\n    BlockType[\"Air\"] = \"Air\";\n    BlockType[\"RedstoneBlock\"] = \"RedstoneBlock\";\n    BlockType[\"RedstoneTorch\"] = \"RedstoneTorch\";\n    BlockType[\"Piston\"] = \"Piston\";\n    BlockType[\"PistonHead\"] = \"PistonHead\";\n    BlockType[\"GlassBlock\"] = \"GlassBlock\";\n    BlockType[\"RedstoneLamp\"] = \"RedstoneLamp\";\n})(BlockType || (exports.BlockType = BlockType = {}));\nfunction isBlock(block, blockType) {\n    return block.type === blockType;\n}\nexports.isBlock = isBlock;\nvar Movement;\n(function (Movement) {\n    Movement[\"None\"] = \"None\";\n    Movement[\"Pending\"] = \"Pending\";\n    Movement[\"Complete\"] = \"Complete\";\n    // extension pending\n    // extension complete\n    // retraction pending\n    Movement[\"RetractionPending\"] = \"RetractionPending\";\n    Movement[\"RetractionComplete\"] = \"RetractionComplete\";\n    // slime???\n})(Movement || (exports.Movement = Movement = {}));\nfunction isMoveableBlock(block) {\n    return 'movement' in block;\n}\nexports.isMoveableBlock = isMoveableBlock;\nfunction isDirectionalBlock(block) {\n    return 'direction' in block;\n}\nexports.isDirectionalBlock = isDirectionalBlock;\n\n\n//# sourceURL=webpack://cellular-redstone/./src/core/block.ts?");

/***/ }),

/***/ "./src/core/command_line.ts":
/*!**********************************!*\
  !*** ./src/core/command_line.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.initCommandLineEventListeners = exports.buildCommandSuggestions = exports.CommandManager = void 0;\nconst general_1 = __webpack_require__(/*! ../utils/general */ \"./src/utils/general.ts\");\nconst commandLineElement = document.getElementById('command-line');\nconst commandListElement = document.getElementById('command-list');\nconst commandListWrapperElement = document.getElementById('command-list-wrapper');\nconst commandListHeadingElement = document.getElementById('command-list-heading');\nclass CommandManager {\n    commands = [];\n    history = [];\n    outputs = [];\n    createCommand(pattern, callback) {\n        this.commands.push({ pattern, callback });\n    }\n    addHistory(item) {\n        const newHistory = this.history.filter(command => command !== item);\n        this.history.length = 0;\n        this.history.push(item);\n        this.history.push(...newHistory);\n    }\n    ifCommandGetInputs(input, command) {\n        const inputs = {};\n        const commandParts = command.split(' ');\n        const inputParts = input.split(' ');\n        for (const [commandPart, inputPart] of (0, general_1.zipArrays)(commandParts, inputParts)) {\n            if (commandPart[0] != '{' && commandPart !== inputPart) {\n                return null;\n            }\n            const input_name = commandPart.split(':')[0].slice(1);\n            const input_value = inputPart;\n            inputs[input_name] = input_value;\n        }\n        return inputs;\n    }\n    isCommandPartialMatch(input, command) {\n        if (input === '')\n            return true;\n        const commandParts = command.split(' ');\n        const inputParts = input.split(' ');\n        const n = inputParts.length;\n        for (let i = 0; i < n - 1; i++) {\n            const commandPart = commandParts[i];\n            const inputPart = inputParts[i];\n            if (commandPart[0] != '{' && commandPart !== inputPart) {\n                return false;\n            }\n        }\n        const commandPart = commandParts[n - 1];\n        const inputPart = inputParts[n - 1];\n        if (commandPart[0] != '{' && !commandPart.startsWith(inputPart)) {\n            return false;\n        }\n        return true;\n    }\n    getNextHistoryItem(input) {\n        if (this.history.length === 0)\n            return '';\n        const currentCommandIndex = this.history.findIndex(item => item === input);\n        let newCommand;\n        if (currentCommandIndex > 0) {\n            newCommand = this.history[0];\n        }\n        else {\n            newCommand = this.history[(currentCommandIndex + 1) % this.history.length];\n        }\n        return newCommand;\n    }\n    getNextHintItem(input) {\n        const viableCommands = this.commands.filter(command => this.isCommandPartialMatch(input, command.pattern));\n        if (viableCommands.length === 0)\n            return '';\n        const currentCommandIndex = this.commands.findIndex(item => item.pattern === input);\n        console.log({ input, viableCommands, currentCommandIndex });\n        let newCommand;\n        if (currentCommandIndex > 0) {\n            newCommand = viableCommands[0];\n        }\n        else {\n            newCommand =\n                viableCommands[(currentCommandIndex + 1) % this.history.length];\n        }\n        return replaceCommandPlaceholders(newCommand.pattern);\n    }\n    async ifCommandExecute(input) {\n        for (const command of this.commands) {\n            const inputs = this.ifCommandGetInputs(input, command.pattern);\n            console.log({ inputs, input, cmd: command.pattern });\n            if (inputs) {\n                this.addHistory(input);\n                const output = await command.callback(inputs);\n                this.outputs.push(output);\n                return;\n            }\n        }\n        this.outputs.push(`command '${input}' not recognised`);\n    }\n}\nexports.CommandManager = CommandManager;\nconst replaceCommandPlaceholders = (input) => {\n    // replaces anything in curley braces with a question mark\n    return input.replace(/\\{[^}]+\\}/g, '?');\n};\nconst focusEndOfCommandLine = () => {\n    commandLineElement.focus();\n    // Set cursor position at the end of the string\n    const inputValueLength = commandLineElement.value.length;\n    commandLineElement.setSelectionRange(inputValueLength, inputValueLength);\n};\nconst buildCommandSuggestions = (cm) => {\n    commandListElement.innerHTML = '';\n    const input = commandLineElement.value;\n    const viableCommands = cm.commands.filter(command => cm.isCommandPartialMatch(input, command.pattern));\n    viableCommands.forEach(command => {\n        const commandItem = document.createElement('div');\n        commandItem.classList.add('command-item');\n        commandItem.textContent = command.pattern;\n        commandItem.onclick = () => {\n            commandLineElement.value = replaceCommandPlaceholders(command.pattern);\n            focusEndOfCommandLine();\n        };\n        commandListElement.appendChild(commandItem);\n    });\n};\nexports.buildCommandSuggestions = buildCommandSuggestions;\nconst buildCommandHistory = (cm) => {\n    commandListElement.innerHTML = '';\n    if (cm.history.length === 0) {\n        const commandItem = document.createElement('div');\n        commandItem.classList.add('command-item');\n        commandItem.textContent = 'no history';\n        commandListElement.appendChild(commandItem);\n    }\n    else {\n        cm.history.forEach(command => {\n            const commandItem = document.createElement('div');\n            commandItem.classList.add('command-item');\n            commandItem.textContent = command;\n            commandItem.onclick = () => {\n                commandLineElement.value = command;\n                focusEndOfCommandLine();\n            };\n            commandListElement.appendChild(commandItem);\n        });\n    }\n};\nconst buildCommandOutput = (cm) => {\n    commandListHeadingElement.textContent = 'OUTPUT';\n    commandListElement.innerHTML = '';\n    if (cm.outputs.length === 0) {\n        const commandItem = document.createElement('div');\n        commandItem.classList.add('command-item');\n        commandItem.textContent = 'no outputs';\n        commandListElement.appendChild(commandItem);\n    }\n    else {\n        cm.outputs.forEach(command => {\n            const commandItem = document.createElement('div');\n            commandItem.classList.add('command-item');\n            commandItem.textContent = command;\n            commandListElement.appendChild(commandItem);\n        });\n    }\n};\nconst initCommandLineEventListeners = (cm) => {\n    document.addEventListener('keydown', event => {\n        if (event.key === '/') {\n            focusEndOfCommandLine();\n        }\n    });\n    let hintItemIndex = 0;\n    commandLineElement.addEventListener('keydown', async (event) => {\n        if (event.key === 'Enter') {\n            // on enter run command or exit command line\n            const command = commandLineElement.value;\n            if (['', '/'].includes(command)) {\n                commandListElement.style.display = 'none';\n                commandLineElement.blur();\n            }\n            await cm.ifCommandExecute(command);\n            commandLineElement.value = '';\n        }\n        else if (event.key === 'Tab') {\n            // on tab select the first suggested command\n            // TODO add tabbing through all options not just first\n            // commandLineElement.value = cm.getNextHintItem(commandBeforeTab)\n            const firstCommandItem = commandListElement.children[hintItemIndex % commandListElement.children.length];\n            Array.from(commandListElement.children).forEach(item => item.classList.remove('selected'));\n            firstCommandItem.classList.add('selected');\n            hintItemIndex += 1;\n            firstCommandItem.click();\n            event.preventDefault();\n        }\n        else if (event.key === 'ArrowUp') {\n            // on arrow up switch through commandHistory\n            commandLineElement.value = cm.getNextHistoryItem(commandLineElement.value);\n            setTimeout(() => {\n                commandListHeadingElement.textContent = 'HISTORY';\n                buildCommandHistory(cm);\n                focusEndOfCommandLine();\n            }, 0);\n        }\n        if (event.key !== 'Tab') {\n            hintItemIndex = 0;\n        }\n        setTimeout(() => {\n            if (commandLineElement.value === '' && cm.outputs.length > 0) {\n                buildCommandOutput(cm);\n            }\n            else if (!['ArrowUp', 'Tab', 'Enter'].includes(event.key)) {\n                commandListHeadingElement.textContent = 'HINT';\n                (0, exports.buildCommandSuggestions)(cm);\n            }\n        }, 0);\n    });\n    let commandLineExitTimeout;\n    // on focus of the command line show suggestions\n    commandLineElement.onfocus = () => {\n        clearTimeout(commandLineExitTimeout);\n        commandListHeadingElement.textContent = 'HINT';\n        if (commandLineElement.value === '' && cm.outputs.length > 0) {\n            buildCommandOutput(cm);\n        }\n        else {\n            (0, exports.buildCommandSuggestions)(cm);\n        }\n        commandListWrapperElement.style.display = '';\n    };\n    // on blur of the command line hide suggestions after delay\n    commandLineElement.onblur = () => {\n        commandLineExitTimeout = setTimeout(() => {\n            if (commandLineElement !== document.activeElement) {\n                commandListWrapperElement.style.display = 'none';\n            }\n        }, 100);\n    };\n};\nexports.initCommandLineEventListeners = initCommandLineEventListeners;\n\n\n//# sourceURL=webpack://cellular-redstone/./src/core/command_line.ts?");

/***/ }),

/***/ "./src/core/direction.ts":
/*!*******************************!*\
  !*** ./src/core/direction.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getAllDirections = exports.directionToVec2 = exports.getRelativeDirection = exports.getOppositeDirection = exports.getOtherDirections = exports.Direction = void 0;\nvar Direction;\n(function (Direction) {\n    Direction[\"Up\"] = \"Up\";\n    Direction[\"Down\"] = \"Down\";\n    Direction[\"Left\"] = \"Left\";\n    Direction[\"Right\"] = \"Right\";\n})(Direction || (exports.Direction = Direction = {}));\nconst getOtherDirections = (direction) => {\n    switch (direction) {\n        case Direction.Up:\n            return [Direction.Left, Direction.Right, Direction.Down];\n        case Direction.Down:\n            return [Direction.Left, Direction.Right, Direction.Up];\n        case Direction.Left:\n            return [Direction.Up, Direction.Right, Direction.Down];\n        case Direction.Right:\n            return [Direction.Left, Direction.Up, Direction.Down];\n    }\n};\nexports.getOtherDirections = getOtherDirections;\nconst getOppositeDirection = (direction) => {\n    switch (direction) {\n        case Direction.Up:\n            return Direction.Down;\n        case Direction.Down:\n            return Direction.Up;\n        case Direction.Left:\n            return Direction.Right;\n        case Direction.Right:\n            return Direction.Left;\n    }\n};\nexports.getOppositeDirection = getOppositeDirection;\nconst getRelativeDirection = (facing, turn) => {\n    switch (facing) {\n        case Direction.Up:\n            return turn;\n        case Direction.Down:\n            switch (turn) {\n                case Direction.Up:\n                    return Direction.Down;\n                case Direction.Down:\n                    return Direction.Up;\n                case Direction.Left:\n                    return Direction.Right;\n                case Direction.Right:\n                    return Direction.Left;\n            }\n        case Direction.Left:\n            switch (turn) {\n                case Direction.Up:\n                    return Direction.Left;\n                case Direction.Down:\n                    return Direction.Right;\n                case Direction.Left:\n                    return Direction.Down;\n                case Direction.Right:\n                    return Direction.Up;\n            }\n        case Direction.Right:\n            switch (turn) {\n                case Direction.Up:\n                    return Direction.Right;\n                case Direction.Down:\n                    return Direction.Left;\n                case Direction.Left:\n                    return Direction.Up;\n                case Direction.Right:\n                    return Direction.Down;\n            }\n    }\n};\nexports.getRelativeDirection = getRelativeDirection;\nconst directionToVec2 = (direction) => {\n    switch (direction) {\n        case Direction.Up:\n            return { x: 0, y: 1 };\n        case Direction.Down:\n            return { x: 0, y: -1 };\n        case Direction.Left:\n            return { x: -1, y: 0 };\n        case Direction.Right:\n            return { x: 1, y: 0 };\n    }\n};\nexports.directionToVec2 = directionToVec2;\nconst getAllDirections = () => {\n    const directions = Object.values(Direction);\n    return directions;\n};\nexports.getAllDirections = getAllDirections;\n\n\n//# sourceURL=webpack://cellular-redstone/./src/core/direction.ts?");

/***/ }),

/***/ "./src/core/moveable_block.ts":
/*!************************************!*\
  !*** ./src/core/moveable_block.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getMovementTextureName = exports.updateMovement = exports.MovementUpdateType = void 0;\nconst air_1 = __webpack_require__(/*! ../blocks/air */ \"./src/blocks/air.ts\");\nconst piston_head_1 = __webpack_require__(/*! ../blocks/piston_head */ \"./src/blocks/piston_head.ts\");\nconst block_fetching_1 = __webpack_require__(/*! ../utils/block_fetching */ \"./src/utils/block_fetching.ts\");\nconst create_block_1 = __webpack_require__(/*! ../utils/create_block */ \"./src/utils/create_block.ts\");\nconst block_1 = __webpack_require__(/*! ./block */ \"./src/core/block.ts\");\nconst direction_1 = __webpack_require__(/*! ./direction */ \"./src/core/direction.ts\");\nvar MovementUpdateType;\n(function (MovementUpdateType) {\n    MovementUpdateType[\"StateChange\"] = \"StateChange\";\n    MovementUpdateType[\"BlockChange\"] = \"BlockChange\";\n})(MovementUpdateType || (exports.MovementUpdateType = MovementUpdateType = {}));\nconst createStateChange = (state) => {\n    return { type: MovementUpdateType.StateChange, state };\n};\nconst createBlockChange = (block) => {\n    return { type: MovementUpdateType.BlockChange, block };\n};\nconst updateMovement = (position, blocks, movement, movementDirection) => {\n    if (movement === block_1.Movement.None) {\n        for (const direction of (0, direction_1.getAllDirections)()) {\n            const neighbour = (0, block_fetching_1.getNeighbourBlock)(position, blocks, direction);\n            const oppositeDirection = (0, block_fetching_1.getOppositeRelativeDirection)(position, blocks, direction);\n            if ((0, block_1.isBlock)(neighbour, block_1.BlockType.Piston) &&\n                neighbour.direction === oppositeDirection &&\n                neighbour.isBeingPowered) {\n                return createStateChange({\n                    movement: block_1.Movement.Pending,\n                    movementDirection: oppositeDirection\n                });\n            }\n            else if ((0, block_1.isMoveableBlock)(neighbour) &&\n                neighbour.movement === block_1.Movement.Pending &&\n                neighbour.movementDirection === oppositeDirection) {\n                return createStateChange({\n                    movement: block_1.Movement.Pending,\n                    movementDirection: oppositeDirection\n                });\n            }\n            else if ((0, block_1.isBlock)(neighbour, block_1.BlockType.PistonHead) &&\n                neighbour.isRetracting &&\n                neighbour.direction === oppositeDirection) {\n                // [piston head retracting] [block] [pending block]\n                return createStateChange({\n                    movement: block_1.Movement.RetractionPending,\n                    movementDirection: oppositeDirection\n                });\n            }\n        }\n    }\n    else if (movement === block_1.Movement.Pending) {\n        const frontNeighbour = (0, block_fetching_1.getNeighbourBlock)(position, blocks, movementDirection, true // movementDirection is an absolute direction\n        );\n        const backNeighbour = (0, block_fetching_1.getNeighbourBlock)(position, blocks, (0, direction_1.getOppositeDirection)(movementDirection), true // movementDirection is an absolute direction\n        );\n        if ((0, block_1.isMoveableBlock)(frontNeighbour) &&\n            frontNeighbour.movement === block_1.Movement.Complete &&\n            frontNeighbour.movementDirection === movementDirection) {\n            if ((0, block_1.isBlock)(backNeighbour, block_1.BlockType.Piston) &&\n                backNeighbour.direction === movementDirection &&\n                backNeighbour.movement === block_1.Movement.None) {\n                return createBlockChange(new piston_head_1.PistonHead({ direction: movementDirection }));\n            }\n            else {\n                return createBlockChange((0, create_block_1.createBlock)(backNeighbour.type, {\n                    ...backNeighbour,\n                    movement: block_1.Movement.Complete,\n                    movementDirection\n                }));\n                // return createStateChange({\n                //   movement: Movement.Complete,\n                //   movementDirection\n                // })\n            }\n        }\n        else {\n            return createStateChange({\n                movement: block_1.Movement.Pending,\n                movementDirection\n            });\n        }\n    }\n    else if (movement === block_1.Movement.RetractionPending) {\n        return createBlockChange(new air_1.Air());\n    }\n    return createStateChange({\n        movement: block_1.Movement.None,\n        movementDirection\n    });\n};\nexports.updateMovement = updateMovement;\nconst getMovementTextureName = (block) => {\n    const movementTex = {\n        [block_1.Movement.None]: '',\n        [block_1.Movement.Pending]: '_extension_pending',\n        [block_1.Movement.Complete]: '_extension_complete',\n        [block_1.Movement.RetractionPending]: '_retraction_pending',\n        [block_1.Movement.RetractionComplete]: '_retraction_complete'\n    }[block.movement];\n    const directionTex = block.movement === block_1.Movement.None\n        ? ''\n        : `_${block.movementDirection.toLowerCase()}`;\n    return `${movementTex}${directionTex}`;\n};\nexports.getMovementTextureName = getMovementTextureName;\n\n\n//# sourceURL=webpack://cellular-redstone/./src/core/moveable_block.ts?");

/***/ }),

/***/ "./src/images/tilemap.ts":
/*!*******************************!*\
  !*** ./src/images/tilemap.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.tilemap = void 0;\nexports.tilemap = {\n    \"glass\": {\n        \"x\": 0,\n        \"y\": 0,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"glass_extension_complete_down\": {\n        \"x\": 16,\n        \"y\": 0,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"glass_extension_complete_left\": {\n        \"x\": 32,\n        \"y\": 0,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"glass_extension_complete_right\": {\n        \"x\": 48,\n        \"y\": 0,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"glass_extension_complete_up\": {\n        \"x\": 64,\n        \"y\": 0,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"glass_extension_pending_down\": {\n        \"x\": 80,\n        \"y\": 0,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"glass_extension_pending_left\": {\n        \"x\": 96,\n        \"y\": 0,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"glass_extension_pending_right\": {\n        \"x\": 112,\n        \"y\": 0,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"glass_extension_pending_up\": {\n        \"x\": 128,\n        \"y\": 0,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"glass_retraction_complete_down\": {\n        \"x\": 144,\n        \"y\": 0,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"glass_retraction_complete_left\": {\n        \"x\": 160,\n        \"y\": 0,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"glass_retraction_complete_right\": {\n        \"x\": 176,\n        \"y\": 0,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"glass_retraction_complete_up\": {\n        \"x\": 192,\n        \"y\": 0,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"glass_retraction_pending_down\": {\n        \"x\": 0,\n        \"y\": 16,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"glass_retraction_pending_left\": {\n        \"x\": 16,\n        \"y\": 16,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"glass_retraction_pending_right\": {\n        \"x\": 32,\n        \"y\": 16,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"glass_retraction_pending_up\": {\n        \"x\": 48,\n        \"y\": 16,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_extended_down\": {\n        \"x\": 64,\n        \"y\": 16,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_extended_left\": {\n        \"x\": 80,\n        \"y\": 16,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_extended_right\": {\n        \"x\": 96,\n        \"y\": 16,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_extended_up\": {\n        \"x\": 112,\n        \"y\": 16,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_head_down\": {\n        \"x\": 128,\n        \"y\": 16,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_head_left\": {\n        \"x\": 144,\n        \"y\": 16,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_head_retracting_down\": {\n        \"x\": 160,\n        \"y\": 16,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_head_retracting_left\": {\n        \"x\": 176,\n        \"y\": 16,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_head_retracting_right\": {\n        \"x\": 192,\n        \"y\": 16,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_head_retracting_up\": {\n        \"x\": 0,\n        \"y\": 32,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_head_right\": {\n        \"x\": 16,\n        \"y\": 32,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_head_up\": {\n        \"x\": 32,\n        \"y\": 32,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_down\": {\n        \"x\": 48,\n        \"y\": 32,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_down_extension_complete_down\": {\n        \"x\": 64,\n        \"y\": 32,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_down_extension_complete_left\": {\n        \"x\": 80,\n        \"y\": 32,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_down_extension_complete_right\": {\n        \"x\": 96,\n        \"y\": 32,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_down_extension_complete_up\": {\n        \"x\": 112,\n        \"y\": 32,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_down_extension_pending_down\": {\n        \"x\": 128,\n        \"y\": 32,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_down_extension_pending_left\": {\n        \"x\": 144,\n        \"y\": 32,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_down_extension_pending_right\": {\n        \"x\": 160,\n        \"y\": 32,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_down_extension_pending_up\": {\n        \"x\": 176,\n        \"y\": 32,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_down_retraction_complete_down\": {\n        \"x\": 192,\n        \"y\": 32,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_down_retraction_complete_left\": {\n        \"x\": 0,\n        \"y\": 48,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_down_retraction_complete_right\": {\n        \"x\": 16,\n        \"y\": 48,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_down_retraction_complete_up\": {\n        \"x\": 32,\n        \"y\": 48,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_down_retraction_pending_down\": {\n        \"x\": 48,\n        \"y\": 48,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_down_retraction_pending_left\": {\n        \"x\": 64,\n        \"y\": 48,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_down_retraction_pending_right\": {\n        \"x\": 80,\n        \"y\": 48,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_down_retraction_pending_up\": {\n        \"x\": 96,\n        \"y\": 48,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_left\": {\n        \"x\": 112,\n        \"y\": 48,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_left_extension_complete_down\": {\n        \"x\": 128,\n        \"y\": 48,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_left_extension_complete_left\": {\n        \"x\": 144,\n        \"y\": 48,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_left_extension_complete_right\": {\n        \"x\": 160,\n        \"y\": 48,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_left_extension_complete_up\": {\n        \"x\": 176,\n        \"y\": 48,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_left_extension_pending_down\": {\n        \"x\": 192,\n        \"y\": 48,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_left_extension_pending_left\": {\n        \"x\": 0,\n        \"y\": 64,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_left_extension_pending_right\": {\n        \"x\": 16,\n        \"y\": 64,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_left_extension_pending_up\": {\n        \"x\": 32,\n        \"y\": 64,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_left_retraction_complete_down\": {\n        \"x\": 48,\n        \"y\": 64,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_left_retraction_complete_left\": {\n        \"x\": 64,\n        \"y\": 64,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_left_retraction_complete_right\": {\n        \"x\": 80,\n        \"y\": 64,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_left_retraction_complete_up\": {\n        \"x\": 96,\n        \"y\": 64,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_left_retraction_pending_down\": {\n        \"x\": 112,\n        \"y\": 64,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_left_retraction_pending_left\": {\n        \"x\": 128,\n        \"y\": 64,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_left_retraction_pending_right\": {\n        \"x\": 144,\n        \"y\": 64,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_left_retraction_pending_up\": {\n        \"x\": 160,\n        \"y\": 64,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_right\": {\n        \"x\": 176,\n        \"y\": 64,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_right_extension_complete_down\": {\n        \"x\": 192,\n        \"y\": 64,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_right_extension_complete_left\": {\n        \"x\": 0,\n        \"y\": 80,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_right_extension_complete_right\": {\n        \"x\": 16,\n        \"y\": 80,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_right_extension_complete_up\": {\n        \"x\": 32,\n        \"y\": 80,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_right_extension_pending_down\": {\n        \"x\": 48,\n        \"y\": 80,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_right_extension_pending_left\": {\n        \"x\": 64,\n        \"y\": 80,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_right_extension_pending_right\": {\n        \"x\": 80,\n        \"y\": 80,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_right_extension_pending_up\": {\n        \"x\": 96,\n        \"y\": 80,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_right_retraction_complete_down\": {\n        \"x\": 112,\n        \"y\": 80,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_right_retraction_complete_left\": {\n        \"x\": 128,\n        \"y\": 80,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_right_retraction_complete_right\": {\n        \"x\": 144,\n        \"y\": 80,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_right_retraction_complete_up\": {\n        \"x\": 160,\n        \"y\": 80,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_right_retraction_pending_down\": {\n        \"x\": 176,\n        \"y\": 80,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_right_retraction_pending_left\": {\n        \"x\": 192,\n        \"y\": 80,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_right_retraction_pending_right\": {\n        \"x\": 0,\n        \"y\": 96,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_right_retraction_pending_up\": {\n        \"x\": 16,\n        \"y\": 96,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_up\": {\n        \"x\": 32,\n        \"y\": 96,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_up_extension_complete_down\": {\n        \"x\": 48,\n        \"y\": 96,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_up_extension_complete_left\": {\n        \"x\": 64,\n        \"y\": 96,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_up_extension_complete_right\": {\n        \"x\": 80,\n        \"y\": 96,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_up_extension_complete_up\": {\n        \"x\": 96,\n        \"y\": 96,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_up_extension_pending_down\": {\n        \"x\": 112,\n        \"y\": 96,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_up_extension_pending_left\": {\n        \"x\": 128,\n        \"y\": 96,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_up_extension_pending_right\": {\n        \"x\": 144,\n        \"y\": 96,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_up_extension_pending_up\": {\n        \"x\": 160,\n        \"y\": 96,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_up_retraction_complete_down\": {\n        \"x\": 176,\n        \"y\": 96,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_up_retraction_complete_left\": {\n        \"x\": 192,\n        \"y\": 96,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_up_retraction_complete_right\": {\n        \"x\": 0,\n        \"y\": 112,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_up_retraction_complete_up\": {\n        \"x\": 16,\n        \"y\": 112,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_up_retraction_pending_down\": {\n        \"x\": 32,\n        \"y\": 112,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_up_retraction_pending_left\": {\n        \"x\": 48,\n        \"y\": 112,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_up_retraction_pending_right\": {\n        \"x\": 64,\n        \"y\": 112,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_off_up_retraction_pending_up\": {\n        \"x\": 80,\n        \"y\": 112,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_on_down\": {\n        \"x\": 96,\n        \"y\": 112,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_on_left\": {\n        \"x\": 112,\n        \"y\": 112,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_on_right\": {\n        \"x\": 128,\n        \"y\": 112,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"piston_on_up\": {\n        \"x\": 144,\n        \"y\": 112,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_block\": {\n        \"x\": 160,\n        \"y\": 112,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_block_extension_complete_down\": {\n        \"x\": 176,\n        \"y\": 112,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_block_extension_complete_left\": {\n        \"x\": 192,\n        \"y\": 112,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_block_extension_complete_right\": {\n        \"x\": 0,\n        \"y\": 128,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_block_extension_complete_up\": {\n        \"x\": 16,\n        \"y\": 128,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_block_extension_pending_down\": {\n        \"x\": 32,\n        \"y\": 128,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_block_extension_pending_left\": {\n        \"x\": 48,\n        \"y\": 128,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_block_extension_pending_right\": {\n        \"x\": 64,\n        \"y\": 128,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_block_extension_pending_up\": {\n        \"x\": 80,\n        \"y\": 128,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_block_retraction_complete_down\": {\n        \"x\": 96,\n        \"y\": 128,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_block_retraction_complete_left\": {\n        \"x\": 112,\n        \"y\": 128,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_block_retraction_complete_right\": {\n        \"x\": 128,\n        \"y\": 128,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_block_retraction_complete_up\": {\n        \"x\": 144,\n        \"y\": 128,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_block_retraction_pending_down\": {\n        \"x\": 160,\n        \"y\": 128,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_block_retraction_pending_left\": {\n        \"x\": 176,\n        \"y\": 128,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_block_retraction_pending_right\": {\n        \"x\": 192,\n        \"y\": 128,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_block_retraction_pending_up\": {\n        \"x\": 0,\n        \"y\": 144,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_lamp_off\": {\n        \"x\": 16,\n        \"y\": 144,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_lamp_off_extension_complete_down\": {\n        \"x\": 32,\n        \"y\": 144,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_lamp_off_extension_complete_left\": {\n        \"x\": 48,\n        \"y\": 144,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_lamp_off_extension_complete_right\": {\n        \"x\": 64,\n        \"y\": 144,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_lamp_off_extension_complete_up\": {\n        \"x\": 80,\n        \"y\": 144,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_lamp_off_extension_pending_down\": {\n        \"x\": 96,\n        \"y\": 144,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_lamp_off_extension_pending_left\": {\n        \"x\": 112,\n        \"y\": 144,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_lamp_off_extension_pending_right\": {\n        \"x\": 128,\n        \"y\": 144,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_lamp_off_extension_pending_up\": {\n        \"x\": 144,\n        \"y\": 144,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_lamp_off_retraction_complete_down\": {\n        \"x\": 160,\n        \"y\": 144,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_lamp_off_retraction_complete_left\": {\n        \"x\": 176,\n        \"y\": 144,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_lamp_off_retraction_complete_right\": {\n        \"x\": 192,\n        \"y\": 144,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_lamp_off_retraction_complete_up\": {\n        \"x\": 0,\n        \"y\": 160,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_lamp_off_retraction_pending_down\": {\n        \"x\": 16,\n        \"y\": 160,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_lamp_off_retraction_pending_left\": {\n        \"x\": 32,\n        \"y\": 160,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_lamp_off_retraction_pending_right\": {\n        \"x\": 48,\n        \"y\": 160,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_lamp_off_retraction_pending_up\": {\n        \"x\": 64,\n        \"y\": 160,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_lamp_on\": {\n        \"x\": 80,\n        \"y\": 160,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_lamp_on_extension_complete_down\": {\n        \"x\": 96,\n        \"y\": 160,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_lamp_on_extension_complete_left\": {\n        \"x\": 112,\n        \"y\": 160,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_lamp_on_extension_complete_right\": {\n        \"x\": 128,\n        \"y\": 160,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_lamp_on_extension_complete_up\": {\n        \"x\": 144,\n        \"y\": 160,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_lamp_on_extension_pending_down\": {\n        \"x\": 160,\n        \"y\": 160,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_lamp_on_extension_pending_left\": {\n        \"x\": 176,\n        \"y\": 160,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_lamp_on_extension_pending_right\": {\n        \"x\": 192,\n        \"y\": 160,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_lamp_on_extension_pending_up\": {\n        \"x\": 0,\n        \"y\": 176,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_lamp_on_retraction_complete_down\": {\n        \"x\": 16,\n        \"y\": 176,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_lamp_on_retraction_complete_left\": {\n        \"x\": 32,\n        \"y\": 176,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_lamp_on_retraction_complete_right\": {\n        \"x\": 48,\n        \"y\": 176,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_lamp_on_retraction_complete_up\": {\n        \"x\": 64,\n        \"y\": 176,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_lamp_on_retraction_pending_down\": {\n        \"x\": 80,\n        \"y\": 176,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_lamp_on_retraction_pending_left\": {\n        \"x\": 96,\n        \"y\": 176,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_lamp_on_retraction_pending_right\": {\n        \"x\": 112,\n        \"y\": 176,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_lamp_on_retraction_pending_up\": {\n        \"x\": 128,\n        \"y\": 176,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_torch_off_down\": {\n        \"x\": 144,\n        \"y\": 176,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_torch_off_left\": {\n        \"x\": 160,\n        \"y\": 176,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_torch_off_right\": {\n        \"x\": 176,\n        \"y\": 176,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_torch_off_up\": {\n        \"x\": 192,\n        \"y\": 176,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_torch_on_down\": {\n        \"x\": 0,\n        \"y\": 192,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_torch_on_left\": {\n        \"x\": 16,\n        \"y\": 192,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_torch_on_right\": {\n        \"x\": 32,\n        \"y\": 192,\n        \"w\": 16,\n        \"h\": 16\n    },\n    \"redstone_torch_on_up\": {\n        \"x\": 48,\n        \"y\": 192,\n        \"w\": 16,\n        \"h\": 16\n    }\n};\n\n\n//# sourceURL=webpack://cellular-redstone/./src/images/tilemap.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst air_1 = __webpack_require__(/*! ./blocks/air */ \"./src/blocks/air.ts\");\nconst glass_block_1 = __webpack_require__(/*! ./blocks/glass_block */ \"./src/blocks/glass_block.ts\");\nconst piston_1 = __webpack_require__(/*! ./blocks/piston */ \"./src/blocks/piston.ts\");\nconst redstone_block_1 = __webpack_require__(/*! ./blocks/redstone_block */ \"./src/blocks/redstone_block.ts\");\nconst redstone_lamp_1 = __webpack_require__(/*! ./blocks/redstone_lamp */ \"./src/blocks/redstone_lamp.ts\");\nconst redstone_torch_1 = __webpack_require__(/*! ./blocks/redstone_torch */ \"./src/blocks/redstone_torch.ts\");\nconst array2d_1 = __webpack_require__(/*! ./containers/array2d */ \"./src/containers/array2d.ts\");\nconst vec2_1 = __webpack_require__(/*! ./containers/vec2 */ \"./src/containers/vec2.ts\");\nconst block_1 = __webpack_require__(/*! ./core/block */ \"./src/core/block.ts\");\nconst command_line_1 = __webpack_require__(/*! ./core/command_line */ \"./src/core/command_line.ts\");\nconst direction_1 = __webpack_require__(/*! ./core/direction */ \"./src/core/direction.ts\");\nconst canvas_1 = __webpack_require__(/*! ./rendering/canvas */ \"./src/rendering/canvas.ts\");\nconst image_loader_1 = __webpack_require__(/*! ./rendering/image_loader */ \"./src/rendering/image_loader.ts\");\nconst create_block_1 = __webpack_require__(/*! ./utils/create_block */ \"./src/utils/create_block.ts\");\n// dom\nconst debugPanel = document.getElementById('debug-panel');\nconst canvasElement = document.getElementById('canvas');\nconst resizeCanvas = () => {\n    const context = canvasElement.getContext('2d');\n    const pixelRatio = window.devicePixelRatio || 1;\n    console.log(pixelRatio);\n    canvasElement.width = canvasElement.clientWidth * pixelRatio;\n    canvasElement.height = canvasElement.clientHeight * pixelRatio;\n    context.imageSmoothingEnabled = false;\n};\nresizeCanvas();\nlet resizeTimeout;\nwindow.addEventListener('resize', () => {\n    clearTimeout(resizeTimeout);\n    resizeTimeout = setTimeout(() => {\n        resizeCanvas();\n    }, 200);\n});\nconst createGlobalValue = (name, initialValue) => {\n    let currentValue = initialValue;\n    const set = (value) => {\n        currentValue = value;\n    };\n    const get = () => {\n        return currentValue;\n    };\n    const display = () => `${name}: ${currentValue}`;\n    const state = { get, set, display };\n    return state;\n};\nconst debounce = (callback, delay) => {\n    let timeoutId;\n    let isPending = false;\n    return function () {\n        if (isPending) {\n            return;\n        }\n        clearTimeout(timeoutId);\n        isPending = true;\n        timeoutId = setTimeout(() => {\n            callback();\n            isPending = false;\n        }, delay);\n    };\n};\nconst GLOBALS = {\n    build: createGlobalValue('BUILD', \"13/01/2024, 15:52:14\"?.replace(',', '')),\n    tick: createGlobalValue('TICK', 0),\n    subtick: createGlobalValue('SUBTICK', 0)\n};\nconst debouncedUpdateDebugInfo = debounce(() => {\n    updateDebugInfo();\n}, 500);\nconst setGlobal = (name, value) => {\n    GLOBALS[name].set(value);\n    debouncedUpdateDebugInfo();\n};\nconst updateDebugInfo = () => {\n    debugPanel.innerHTML = '';\n    Object.values(GLOBALS).forEach(globalValue => {\n        const item = document.createElement('div');\n        item.textContent = globalValue.display();\n        debugPanel.appendChild(item);\n    });\n};\nconst logBlocks = (blocks) => {\n    console.log(blocks);\n};\nconst subUpdateBlocks = (blocks) => {\n    setGlobal('subtick', (GLOBALS.subtick.get() + 1) % 16);\n    const newBlocks = blocks.map((block, v) => block.subupdate(v, blocks));\n    blocks.clone(newBlocks);\n};\nconst updateBlocks = (blocks) => {\n    setGlobal('tick', GLOBALS.tick.get() + 1);\n    const newBlocks = blocks.map((block, v) => block.update(v, blocks));\n    blocks.clone(newBlocks);\n    const blocksForStorage = blocks.mapToDict2D((block, v) => {\n        return block;\n    });\n    localStorage.setItem('chunks', JSON.stringify(blocksForStorage.items));\n    // logBlocks(blocks)\n};\nconst addClickHandlerWithDragCheck = (element, clickCallback) => {\n    let isDragging = false;\n    const mouseDownHandler = (_downEvent) => {\n        isDragging = false;\n        const mouseMoveHandler = (_moveEvent) => {\n            isDragging = true;\n        };\n        const mouseUpHandler = () => {\n            document.removeEventListener('mousemove', mouseMoveHandler);\n            document.removeEventListener('mouseup', mouseUpHandler);\n            if (!isDragging) {\n                // Invoke the callback for a regular click\n                clickCallback();\n            }\n        };\n        document.addEventListener('mousemove', mouseMoveHandler);\n        document.addEventListener('mouseup', mouseUpHandler);\n    };\n    element.addEventListener('mousedown', mouseDownHandler);\n};\nconst loadChunksFromStorage = async (allowLocalStorage = true, allowWorldDemos = true) => {\n    const chunksRaw = localStorage.getItem('chunks');\n    const blocks = new array2d_1.ChunkContainer(16, () => new air_1.Air({}), (block) => block.type === block_1.BlockType.Air, true);\n    // console.log('chunksRaw', chunksRaw)\n    const loadChunks = (chunks) => {\n        const chunkDict = new array2d_1.Dict2D(chunks);\n        console.log(chunkDict);\n        chunkDict.map((block, v) => {\n            blocks.setValue(v, (0, create_block_1.createBlock)(block.type, block));\n        });\n    };\n    if (chunksRaw && allowLocalStorage) {\n        const chunks = JSON.parse(chunksRaw);\n        loadChunks(chunks);\n    }\n    else if (allowWorldDemos) {\n        const chunks = (await loadWorldSave());\n        loadChunks(chunks);\n    }\n    placeAllBlocks(blocks);\n    return blocks;\n};\nconst main = async () => {\n    console.log('main');\n    const blocks = await loadChunksFromStorage();\n    const canvas = new canvas_1.Canvas(canvasElement, await (0, image_loader_1.loadImages)(), 40, 1.05, (0, vec2_1.vec2Zero)());\n    const updateCanvas = () => {\n        const gridImages = blocks.mapToDict2D((block, v) => {\n            return block.getTextureName(v, blocks);\n        });\n        canvas.setGridImages(gridImages);\n        canvas.render();\n    };\n    let selectedBlockType = block_1.BlockType.Air;\n    let previousSelectedBlockType = block_1.BlockType.Air;\n    const placeBlock = () => {\n        const p = canvas.getMouseWorldPosition();\n        const pi = (0, vec2_1.vec2Apply)(p, Math.floor);\n        const getPlacementDirection = (v) => {\n            if (Math.abs(v.x - 0.5) > Math.abs(v.y - 0.5)) {\n                return v.x > 0.5 ? direction_1.Direction.Right : direction_1.Direction.Left;\n            }\n            else {\n                return v.y > 0.5 ? direction_1.Direction.Up : direction_1.Direction.Down;\n            }\n        };\n        const direction = getPlacementDirection((0, vec2_1.vec2Subtract)(p, pi));\n        const block = blocks.getValue(pi);\n        if (block.type === block_1.BlockType.Air) {\n            const newBlock = (0, create_block_1.createBlock)(selectedBlockType, { direction });\n            blocks.setValue(pi, newBlock);\n            blocks.setValue(pi, newBlock.update(pi, blocks));\n            updateCanvas();\n        }\n        else {\n            if (block.type != selectedBlockType) {\n                previousSelectedBlockType = selectedBlockType;\n            }\n            selectedBlockType = block.type;\n        }\n        // console.log(p, pi, block)\n    };\n    addClickHandlerWithDragCheck(canvasElement, placeBlock);\n    // canvasElement.addEventListener('click')\n    canvasElement.addEventListener('dblclick', function (e) {\n        e.preventDefault();\n        const p = canvas.getMouseWorldPosition();\n        const pi = (0, vec2_1.vec2Apply)(p, Math.floor);\n        blocks.setValue(pi, new air_1.Air({}));\n        // on double click we also perform the single click action of selecting the\n        // block we just deleted. Revert the selection\n        selectedBlockType = previousSelectedBlockType;\n        updateCanvas();\n    });\n    document.addEventListener('keydown', event => {\n        if (event.key === 'e') {\n            const p = canvas.getMouseWorldPosition();\n            const pi = (0, vec2_1.vec2Apply)(p, Math.floor);\n            console.log(blocks.getValue(pi));\n        }\n    });\n    // Updates Per Second\n    const processUpdatesPerSecondInput = (value) => {\n        const speed = Number(value);\n        game.setUpdatesPerSecond(speed);\n    };\n    const updatesPerSecondValue = localStorage.getItem('updatesPerSecond') ?? 5;\n    // Sub-Updates Per Second\n    const subUpdatesPerSecondValue = localStorage.getItem('subUpdatesPerSecond') ?? 1000;\n    let subUpdatesPerSecond = Number(subUpdatesPerSecondValue);\n    let subUpdateTimeStep = subUpdatesPerSecond > 0 ? 1000 / subUpdatesPerSecond : 0;\n    let canSubUpdate = false;\n    const setSubUpdatesPerSecond = (x) => {\n        subUpdatesPerSecond = Number(x);\n        subUpdateTimeStep = subUpdatesPerSecond > 0 ? 1000 / subUpdatesPerSecond : 0;\n        localStorage.setItem('subUpdatesPerSecond', String(x));\n    };\n    const game = new Game(Number(updatesPerSecondValue), () => {\n        let lastUpdateTime = 0;\n        let iteration = 0;\n        // console.log('help', { canSubUpdate, subUpdateTimeStep })\n        if (subUpdateTimeStep < 10) {\n            // if subUpdateTimeStep very fast then just loop through subupdates\n            // as quickly as possible\n            for (let i = 0; i < 16; ++i) {\n                subUpdateBlocks(blocks);\n            }\n            updateBlocks(blocks);\n            updateCanvas();\n            game.setUpdateComplete();\n            return;\n        }\n        const runSubUpdate = (currentTime) => {\n            let deltaTime = currentTime - lastUpdateTime;\n            if (canSubUpdate ||\n                (subUpdateTimeStep > 0 && deltaTime >= subUpdateTimeStep)) {\n                canSubUpdate = false;\n                subUpdateBlocks(blocks);\n                if (subUpdateTimeStep === 0) {\n                    // only update the canvas if we are viewing subupdates\n                    updateCanvas();\n                }\n                lastUpdateTime = currentTime - (deltaTime % subUpdateTimeStep);\n                if (isNaN(lastUpdateTime)) {\n                    lastUpdateTime = 0;\n                }\n                iteration += 1;\n                if (iteration < 16) {\n                    // console.log('subupdate', iteration)\n                }\n                else {\n                    // console.log('update')\n                    updateBlocks(blocks);\n                    updateCanvas();\n                    game.setUpdateComplete();\n                    return;\n                }\n            }\n            requestAnimationFrame(runSubUpdate);\n        };\n        requestAnimationFrame(runSubUpdate);\n    });\n    logBlocks(blocks);\n    updateCanvas();\n    // load commands\n    const commandManager = new command_line_1.CommandManager();\n    commandManager.createCommand('/load_world {name:string}', async (input) => {\n        blocks.chunks = (await loadChunksFromStorage(false, true)).chunks;\n        updateCanvas();\n        return `loaded world ${input.name}`;\n    });\n    commandManager.createCommand('/clear_world', async () => {\n        blocks.chunks = (await loadChunksFromStorage(false, false)).chunks;\n        updateCanvas();\n        return `cleared world`;\n    });\n    commandManager.createCommand('/step tick', async () => {\n        // updatesPerSecondInput.value = '0'\n        game.setUpdatesPerSecond(0);\n        game.allowTimeStep();\n        return `stepped tick to ${GLOBALS.subtick.get()}`;\n    });\n    commandManager.createCommand('/step subtick', async () => {\n        // subUpdatesPerSecondInput.value = '0'\n        setSubUpdatesPerSecond(0);\n        canSubUpdate = true;\n        return `stepped subtick to ${GLOBALS.subtick.get()}`;\n    });\n    commandManager.createCommand('/set updates per second {ups:float}', async (input) => {\n        processUpdatesPerSecondInput(input.ups);\n        return `set updates per second ${input.ups}`;\n    });\n    commandManager.createCommand('/set subupdates_per_second {sups:float}', async (input) => {\n        const sups = Number(input.sups);\n        if (!isNaN(sups)) {\n            setSubUpdatesPerSecond(sups);\n            return `set subupdates per second ${sups}`;\n        }\n        else {\n            return `subupdates per second was not a number`;\n        }\n    });\n    commandManager.createCommand('/toggle debug_window', async (input) => {\n        if (debugPanel.style.display == 'none') {\n            debugPanel.style.display = '';\n            return 'debug window displayed';\n        }\n        else {\n            debugPanel.style.display = 'none';\n            return 'debug window hidden';\n        }\n    });\n    (0, command_line_1.initCommandLineEventListeners)(commandManager);\n    game.startGameLoop();\n};\nconst placeAllBlocks = (blocks) => {\n    blocks.setValue({ x: 0, y: 0 }, new redstone_block_1.RedstoneBlock({}));\n    blocks.setValue({ x: 2, y: 0 }, new redstone_torch_1.RedstoneTorch({}));\n    blocks.setValue({ x: 4, y: 0 }, new redstone_lamp_1.RedstoneLamp({}));\n    blocks.setValue({ x: 6, y: 0 }, new piston_1.Piston({}));\n    blocks.setValue({ x: 8, y: 0 }, new glass_block_1.GlassBlock({}));\n};\nconst loadWorldSave = async () => {\n    try {\n        const response = await fetch('saves/world1.json');\n        if (!response.ok) {\n            throw new Error(`HTTP error! Status: ${response.status}`);\n        }\n        const jsonData = await response.json();\n        console.log('JSON data:', jsonData);\n        return jsonData;\n    }\n    catch (error) {\n        console.error('Error fetching JSON:', error);\n    }\n};\nclass Game {\n    lastUpdateTime = 0;\n    updateTimeStep;\n    updateCallback;\n    canTimeStep = false;\n    hasUpdateCompleted = true;\n    constructor(updatesPerSecond, updateCallback) {\n        this.updateTimeStep = 1000 / updatesPerSecond;\n        this.updateCallback = updateCallback;\n        this.canTimeStep = false;\n    }\n    setUpdateComplete() {\n        this.hasUpdateCompleted = true;\n    }\n    allowTimeStep() {\n        this.canTimeStep = true;\n    }\n    setUpdatesPerSecond(updatesPerSecond) {\n        if (updatesPerSecond <= 0) {\n            this.updateTimeStep = 0;\n        }\n        else {\n            this.updateTimeStep = 1000 / updatesPerSecond;\n        }\n    }\n    update = (currentTime) => {\n        if (this.hasUpdateCompleted) {\n            let deltaTime = currentTime - this.lastUpdateTime;\n            if (this.canTimeStep ||\n                (this.updateTimeStep > 0 && deltaTime >= this.updateTimeStep)) {\n                this.canTimeStep = false;\n                this.hasUpdateCompleted = false;\n                this.updateCallback();\n                this.lastUpdateTime = currentTime - (deltaTime % this.updateTimeStep);\n                if (isNaN(this.lastUpdateTime)) {\n                    this.lastUpdateTime = 0;\n                }\n            }\n        }\n        requestAnimationFrame(this.update);\n    };\n    startGameLoop = () => {\n        requestAnimationFrame(this.update);\n    };\n}\nmain();\n\n\n//# sourceURL=webpack://cellular-redstone/./src/index.ts?");

/***/ }),

/***/ "./src/rendering/canvas.ts":
/*!*********************************!*\
  !*** ./src/rendering/canvas.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Canvas = void 0;\nconst array2d_1 = __webpack_require__(/*! ../containers/array2d */ \"./src/containers/array2d.ts\");\nconst vec2_1 = __webpack_require__(/*! ../containers/vec2 */ \"./src/containers/vec2.ts\");\nconst tilemap_1 = __webpack_require__(/*! ../images/tilemap */ \"./src/images/tilemap.ts\");\nfunction roundToNearestPowerOf2(number) {\n    // Check if the number is already a power of 2\n    if ((number & (number - 1)) === 0) {\n        return number;\n    }\n    // Find the nearest power of 2 greater than the given number\n    let power = 1;\n    while (power < number) {\n        power <<= 1;\n    }\n    // Check if the lower or upper power of 2 is closer\n    const lowerPower = power >>> 1;\n    const upperPower = power;\n    return upperPower - number < number - lowerPower ? upperPower : lowerPower;\n}\nfunction floorToNearest(value, target) {\n    return Math.floor(value / target) * target;\n}\nclass Canvas {\n    canvas;\n    ctx;\n    images;\n    imageGrid;\n    // panning and scaling\n    scale;\n    scaleFactor;\n    offset;\n    mouse;\n    constructor(canvas, images, scale, scaleFactor, offset) {\n        this.canvas = canvas;\n        // no anti-aliasing\n        this.ctx = canvas.getContext('2d');\n        this.ctx.imageSmoothingEnabled = false;\n        this.images = images;\n        this.imageGrid = new array2d_1.Dict2D();\n        this.scale = scale;\n        this.scaleFactor = scaleFactor;\n        this.offset = offset;\n        this.mouse = { x: 0, y: 0 };\n        this.handlePanning();\n        this.handleScaling();\n    }\n    // screen to canvas AND canvas to screen\n    calculateAxisFlippedPosition = (x, y) => {\n        return { x: x, y: this.canvas.height - y };\n    };\n    // world to canvas\n    calculateWorldToScreenPosition = (x, y) => {\n        return {\n            x: x * this.scale + this.offset.x,\n            y: y * this.scale + this.offset.y\n        };\n    };\n    // canvas to world\n    calculateScreenToWorldPosition = (x, y) => {\n        return {\n            x: (x - this.offset.x) / this.scale,\n            y: (y - this.offset.y) / this.scale\n        };\n    };\n    getMouseWorldPosition() {\n        const axisFlippedPos = this.calculateAxisFlippedPosition(this.mouse.x, this.mouse.y);\n        const worldPos = this.calculateScreenToWorldPosition(axisFlippedPos.x, axisFlippedPos.y);\n        return worldPos;\n    }\n    handlePanning = () => {\n        const canvas = this.canvas;\n        let lastMouse = { x: 0, y: 0 };\n        let isPanning = false;\n        let hasMetMinimumMovementThreshold = false;\n        let movementThreshold = 8;\n        const handleMouseMove = (event) => {\n            this.mouse = { x: event.offsetX, y: event.offsetY };\n            if (isPanning) {\n                const mouseOffset = (0, vec2_1.vec2Subtract)(this.mouse, lastMouse);\n                if (Math.abs(mouseOffset.x) > movementThreshold ||\n                    Math.abs(mouseOffset.y) > movementThreshold) {\n                    hasMetMinimumMovementThreshold = true;\n                    lastMouse = this.mouse;\n                }\n                else if (hasMetMinimumMovementThreshold) {\n                    lastMouse = this.mouse;\n                    this.offset = (0, vec2_1.vec2Add)(this.offset, {\n                        x: mouseOffset.x,\n                        y: -mouseOffset.y\n                    });\n                    this.render();\n                }\n            }\n            else {\n                hasMetMinimumMovementThreshold = false;\n                lastMouse = this.mouse;\n            }\n        };\n        canvas.addEventListener('mousemove', handleMouseMove);\n        canvas.addEventListener('mousedown', () => (isPanning = true));\n        canvas.addEventListener('mouseup', () => (isPanning = false));\n        canvas.addEventListener('mouseleave', () => (isPanning = false));\n    };\n    handleScaling = () => {\n        const handleScroll = (event) => {\n            // scaleOrigin in world pos\n            const axisFlippedOrigin = this.calculateAxisFlippedPosition(this.mouse.x, this.mouse.y);\n            const worldOrigin = this.calculateScreenToWorldPosition(axisFlippedOrigin.x, axisFlippedOrigin.y);\n            const preScaleScreenOrigin = this.calculateWorldToScreenPosition(worldOrigin.x, worldOrigin.y);\n            if (event.deltaY > 0) {\n                this.scale /= this.scaleFactor;\n            }\n            else if (event.deltaY < 0) {\n                this.scale *= this.scaleFactor;\n            }\n            const postScaleScreenOrigin = this.calculateWorldToScreenPosition(worldOrigin.x, worldOrigin.y);\n            const scaleOffset = (0, vec2_1.vec2Subtract)(preScaleScreenOrigin, postScaleScreenOrigin);\n            this.offset = (0, vec2_1.vec2Add)(this.offset, scaleOffset);\n            this.render();\n        };\n        this.canvas.addEventListener('wheel', handleScroll);\n    };\n    drawText = (text, x, y) => {\n        const q1 = this.calculateWorldToScreenPosition(x, y);\n        const p = this.calculateAxisFlippedPosition(q1.x, q1.y);\n        const offset = 20;\n        if ((p.x < offset || p.x > this.canvas.width - offset) &&\n            (p.y < offset || p.y > this.canvas.height - offset)) {\n            return;\n        }\n        const topRight = this.calculateScreenToWorldPosition(this.canvas.width, this.canvas.height);\n        const bottomLeft = this.calculateScreenToWorldPosition(0, 0);\n        let numCellsWide = topRight.x - bottomLeft.x;\n        const gridSize = Math.max(1, Math.floor(roundToNearestPowerOf2(numCellsWide / 10)));\n        const screenCellWidth = this.canvas.width / (numCellsWide / gridSize);\n        this.ctx.fillStyle = 'white';\n        this.ctx.font = `${screenCellWidth / 4}px Sora`;\n        // this.ctx.strokeStyle = 'white'\n        // this.ctx.lineWidth = 1\n        // this.ctx.strokeText(text, p.x, p.y - 4, screenCellWidth)\n        this.ctx.fillText(text, p.x + 3, p.y - 4, screenCellWidth);\n    };\n    drawRect = (x, y, w, h) => {\n        const q1 = this.calculateWorldToScreenPosition(x, y);\n        const p = this.calculateAxisFlippedPosition(q1.x, q1.y);\n        this.ctx.fillRect(p.x, p.y, w * this.scale, h * this.scale);\n    };\n    drawImage = (imageName, x, y, w, h) => {\n        const tileInfo = tilemap_1.tilemap[imageName];\n        if (!tileInfo) {\n            console.warn(`ImageName: ${imageName} missing from tilemap`);\n            return;\n        }\n        const image = this.images.get('combinedImage');\n        if (!image)\n            return;\n        // console.log(imageName, tileInfo)\n        const q1 = this.calculateWorldToScreenPosition(x, y);\n        const p = this.calculateAxisFlippedPosition(q1.x, q1.y + this.scale);\n        this.ctx.drawImage(image, tileInfo.x, tileInfo.y, tileInfo.w, tileInfo.h, Math.floor(p.x), Math.floor(p.y), Math.floor(w * this.scale), Math.floor(h * this.scale));\n    };\n    drawLine = (x1, y1, x2, y2) => {\n        const q1 = this.calculateWorldToScreenPosition(x1, y1);\n        const p1 = this.calculateAxisFlippedPosition(q1.x, q1.y);\n        const q2 = this.calculateWorldToScreenPosition(x2, y2);\n        const p2 = this.calculateAxisFlippedPosition(q2.x, q2.y);\n        this.ctx.beginPath();\n        this.ctx.moveTo(Math.round(p1.x), Math.round(p1.y));\n        this.ctx.lineTo(Math.round(p2.x), Math.round(p2.y));\n        this.ctx.stroke();\n    };\n    drawGridOverlay() {\n        const topRight = this.calculateScreenToWorldPosition(this.canvas.width, this.canvas.height);\n        const bottomLeft = this.calculateScreenToWorldPosition(0, 0);\n        let numCellsWide = topRight.x - bottomLeft.x;\n        let gridSize = Math.max(1, Math.floor(roundToNearestPowerOf2(numCellsWide / 10)));\n        const setLineStyle = (z) => {\n            const isMajorLine = z % (gridSize * 4) === 0;\n            this.ctx.lineWidth = isMajorLine ? 1 : 1;\n            this.ctx.strokeStyle = `rgba(255, 255, 255, ${isMajorLine ? 0.6 : 0.2})`;\n        };\n        for (let y = floorToNearest(bottomLeft.y, gridSize); y < topRight.y; y += gridSize) {\n            setLineStyle(y);\n            this.drawLine(bottomLeft.x, y, topRight.x, y);\n            this.drawText(`${y}`, bottomLeft.x, y);\n        }\n        for (let x = floorToNearest(bottomLeft.x, gridSize); x < topRight.x; x += gridSize) {\n            setLineStyle(x);\n            this.drawLine(x, bottomLeft.y, x, topRight.y);\n            this.drawText(`${x}`, x, bottomLeft.y);\n        }\n    }\n    drawGrid() {\n        const topRight = (0, vec2_1.vec2Apply)(this.calculateScreenToWorldPosition(this.canvas.width, this.canvas.height), Math.floor);\n        const bottomLeft = (0, vec2_1.vec2Apply)(this.calculateScreenToWorldPosition(0, 0), Math.floor);\n        // TODO automatically which render method depending on render space\n        // and grid size. Could chunk imageGrid as well.\n        if (true) {\n            // attempt to render all blocks and cull those outside render space\n            // good if blocks in world < blocks in render space\n            this.imageGrid.foreach((textureName, v) => {\n                if (v.x >= bottomLeft.x &&\n                    v.x <= topRight.x + 1 &&\n                    v.y >= bottomLeft.y &&\n                    v.y <= topRight.y + 1) {\n                    this.drawImage(textureName, v.x, v.y, 1, 1);\n                }\n            });\n        }\n        else {}\n    }\n    setGridImages(imageGrid) {\n        this.imageGrid = imageGrid;\n    }\n    render() {\n        this.ctx.fillStyle = 'rgb(18, 91, 167)';\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n        this.drawGridOverlay();\n        this.drawGrid();\n    }\n}\nexports.Canvas = Canvas;\n\n\n//# sourceURL=webpack://cellular-redstone/./src/rendering/canvas.ts?");

/***/ }),

/***/ "./src/rendering/image_loader.ts":
/*!***************************************!*\
  !*** ./src/rendering/image_loader.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.loadImages = void 0;\nconst fetchPngFilenames = () => {\n    const context = __webpack_require__(\"./src/images sync \\\\.png$\");\n    return context.keys().map(filename => filename.replace('./', ''));\n};\nconst loadImage = async (path) => {\n    return new Promise(resolve => {\n        const img = new Image();\n        img.src = path;\n        img.onload = () => {\n            resolve(img);\n        };\n    });\n};\nconst loadImages = async () => {\n    const images = new Map();\n    const imagePaths = fetchPngFilenames();\n    console.log(imagePaths);\n    const loadImagePromises = imagePaths.map(async (path) => {\n        const img = await loadImage('./src/images/' + path);\n        images.set(path.replace('.png', ''), img);\n    });\n    await Promise.all(loadImagePromises);\n    return images;\n};\nexports.loadImages = loadImages;\n\n\n//# sourceURL=webpack://cellular-redstone/./src/rendering/image_loader.ts?");

/***/ }),

/***/ "./src/utils/block_fetching.ts":
/*!*************************************!*\
  !*** ./src/utils/block_fetching.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getAllNeighbourBlocks = exports.getNeighbourBlocks = exports.getOppositeRelativeDirection = exports.getNeighbourBlock = void 0;\nconst air_1 = __webpack_require__(/*! ../blocks/air */ \"./src/blocks/air.ts\");\nconst vec2_1 = __webpack_require__(/*! ../containers/vec2 */ \"./src/containers/vec2.ts\");\nconst block_1 = __webpack_require__(/*! ../core/block */ \"./src/core/block.ts\");\nconst direction_1 = __webpack_require__(/*! ../core/direction */ \"./src/core/direction.ts\");\nconst getNeighbourBlock = (position, blocks, direction, useAbsoluteDirection = false) => {\n    const block = blocks.getValue(position);\n    let relativeDirection = direction;\n    if ((0, block_1.isDirectionalBlock)(block) && !useAbsoluteDirection) {\n        relativeDirection = (0, direction_1.getRelativeDirection)(block.direction, direction);\n    }\n    const offset = (0, direction_1.directionToVec2)(relativeDirection);\n    const neighbour = blocks.getValue((0, vec2_1.vec2Add)(position, offset)) ?? new air_1.Air();\n    return neighbour;\n};\nexports.getNeighbourBlock = getNeighbourBlock;\nconst getOppositeRelativeDirection = (position, blocks, direction) => {\n    const block = blocks.getValue(position);\n    let relativeDirection = direction;\n    if ((0, block_1.isDirectionalBlock)(block)) {\n        relativeDirection = (0, direction_1.getRelativeDirection)(block.direction, direction);\n    }\n    return (0, direction_1.getOppositeDirection)(relativeDirection);\n};\nexports.getOppositeRelativeDirection = getOppositeRelativeDirection;\nconst getNeighbourBlocks = (position, blocks, directions) => {\n    return directions.map(direction => (0, exports.getNeighbourBlock)(position, blocks, direction));\n};\nexports.getNeighbourBlocks = getNeighbourBlocks;\nconst getAllNeighbourBlocks = (position, blocks) => {\n    return (0, direction_1.getAllDirections)().map(direction => (0, exports.getNeighbourBlock)(position, blocks, direction));\n};\nexports.getAllNeighbourBlocks = getAllNeighbourBlocks;\n\n\n//# sourceURL=webpack://cellular-redstone/./src/utils/block_fetching.ts?");

/***/ }),

/***/ "./src/utils/create_block.ts":
/*!***********************************!*\
  !*** ./src/utils/create_block.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createBlock = exports.addCreateBlockFunction = void 0;\nconst createBlockFunctions = {};\nconst addCreateBlockFunction = (blockType, blockConstructor) => {\n    createBlockFunctions[blockType] = blockConstructor;\n};\nexports.addCreateBlockFunction = addCreateBlockFunction;\nconst createBlock = (blockType, state) => {\n    const blockConstructor = createBlockFunctions[blockType];\n    if (!blockConstructor) {\n        throw new Error(`Block constructor for block type ${blockType} not implemented`);\n    }\n    return new blockConstructor(state);\n};\nexports.createBlock = createBlock;\n\n\n//# sourceURL=webpack://cellular-redstone/./src/utils/create_block.ts?");

/***/ }),

/***/ "./src/utils/general.ts":
/*!******************************!*\
  !*** ./src/utils/general.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getMissingKeys = exports.zipArrays = void 0;\nconst zipArrays = (arr1, arr2) => {\n    const zippedArray = [];\n    const minLength = Math.min(arr1.length, arr2.length);\n    for (let i = 0; i < minLength; i++) {\n        zippedArray.push([arr1[i], arr2[i]]);\n    }\n    return zippedArray;\n};\nexports.zipArrays = zipArrays;\nconst getMissingKeys = (a, b) => {\n    const missingKeys = [];\n    for (const key in b) {\n        if (b.hasOwnProperty(key) && !a.hasOwnProperty(key)) {\n            missingKeys.push(key);\n        }\n    }\n    return missingKeys;\n};\nexports.getMissingKeys = getMissingKeys;\n\n\n//# sourceURL=webpack://cellular-redstone/./src/utils/general.ts?");

/***/ }),

/***/ "./src/images sync \\.png$":
/*!**********************************************!*\
  !*** ./src/images/ sync nonrecursive \.png$ ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var map = {\n\t\"./combinedImage.png\": \"./src/images/combinedImage.png\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./src/images sync \\\\.png$\";\n\n//# sourceURL=webpack://cellular-redstone/./src/images/_sync_nonrecursive_\\.png$?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && !scriptUrl) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;